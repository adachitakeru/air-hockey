<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>P2P エアホッケー (PeerJS実装)</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; background-color: #f0f0f0; touch-action: none; -webkit-tap-highlight-color: transparent; /* タップ時のハイライト無効化 */ }
        #gameContainer { position: relative; width: 90vw; max-width: 400px; margin-top: 10px; }
        canvas { border: 2px solid black; background-color: #fff; display: block; width: 100%; aspect-ratio: 2 / 3; }
        .info-area, .controls, .p2p-info { margin-top: 10px; text-align: center; width: 90%; max-width: 400px; }
        button { padding: 10px 15px; margin: 5px; font-size: 16px; cursor: pointer; border-radius: 5px; border: 1px solid #ccc; }
        button.primary { background-color: #007bff; color: white; }
        button.secondary { background-color: #6c757d; color: white; }
        #qrCodeContainer { margin: 10px auto; width: 150px; height: 150px; border: 1px solid #ddd; background-color: white; padding: 5px; }
        #roomInfo { margin-top: 5px; font-size: 14px; word-break: break-all; }
        .hidden { display: none !important; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
</head>
<body>
    <h1>P2P エアホッケー</h1>

    <div id="gameContainer">
        <canvas id="airHockeyCanvas"></canvas>
    </div>

    <div class="info-area">
        <p id="score">あなた: 0 - AI: 0</p>
        <p id="gameStatus">ようこそ！</p>
    </div>

    <div id="initialControls" class="controls">
        <button id="hostGameButton" class="primary">部屋を作成 (QR表示 & AI対戦)</button>
        <p style="font-size: 0.9em; margin-top: 10px;">または、友達から送られたURLで参加してください。</p>
    </div>

    <div id="p2pHostInfo" class="p2p-info hidden">
        <p>友達が参加するまでAIと対戦します。</p>
        <p>このQRコードを友達にスキャンしてもらうか、以下の情報を伝えてください:</p>
        <div id="qrCodeContainer"></div>
        <div id="roomInfo"></div>
        <button id="cancelHostButton" class="secondary" style="margin-top:10px;">ホスティング中止</button>
    </div>
    
    <div id="p2pClientInfo" class="p2p-info hidden">
        <p id="joinStatus"></p>
    </div>

    <script>
        const canvas = document.getElementById('airHockeyCanvas');
        const ctx = canvas.getContext('2d');

        const scoreDisplay = document.getElementById('score');
        const gameStatusDisplay = document.getElementById('gameStatus');
        const initialControls = document.getElementById('initialControls');
        const hostGameButton = document.getElementById('hostGameButton');
        const p2pHostInfo = document.getElementById('p2pHostInfo');
        const qrCodeContainer = document.getElementById('qrCodeContainer');
        const roomInfoDisplay = document.getElementById('roomInfo');
        const cancelHostButton = document.getElementById('cancelHostButton');
        const p2pClientInfo = document.getElementById('p2pClientInfo');
        const joinStatusDisplay = document.getElementById('joinStatus');

        let PADDLE_RADIUS = 20, PUCK_RADIUS = 15, GOAL_WIDTH = 100;
        const WINNING_SCORE = 10;
        const PADDLE_SPEED_FACTOR = 0.15; // パドルの追従性を少し上げた
        let canvasWidth, canvasHeight;

        let player1 = { x: 0, y: 0, score: 0, radius: PADDLE_RADIUS, targetX: 0, targetY: 0, name: "あなた" };
        let player2 = { x: 0, y: 0, score: 0, radius: PADDLE_RADIUS, isAI: true, targetX: 0, targetY: 0, name: "AI" };
        let puck = { x: 0, y: 0, vx: 0, vy: 0, radius: PUCK_RADIUS };

        let gameMode = 'menu'; 
        let localPlayerRole = null; 
        let animationFrameId;
        let isTouching = false; // タッチ操作中かどうかのフラグ

        let peer, conn, myPeerId, hostPeerIdToConnect;

        function cleanupPeerResources() { /* (変更なし) */ if(conn){conn.close();conn=null;}if(peer){peer.destroy();peer=null;}myPeerId=null;hostPeerIdToConnect=null; }
        function resizeCanvas() { /* (変更なし) */ const c=document.getElementById('gameContainer'),a=2/3;let nw=c.clientWidth,nh=nw/a;if(nh>window.innerHeight*0.7){nh=window.innerHeight*0.7;nw=nh*a;}canvas.width=nw;canvas.height=nh;canvasWidth=canvas.width;canvasHeight=canvas.height;PADDLE_RADIUS=canvasWidth/20;PUCK_RADIUS=canvasWidth/27;GOAL_WIDTH=canvasWidth/4;player1.radius=PADDLE_RADIUS;player2.radius=PADDLE_RADIUS;puck.radius=PUCK_RADIUS;if(gameMode!=='menu')initGameElements();else drawField(); }
        function initGameElements() { /* (変更なし) */ player1.x=canvasWidth/2;player1.y=canvasHeight*0.85;player1.targetX=player1.x;player1.targetY=player1.y;player2.x=canvasWidth/2;player2.y=canvasHeight*0.15;player2.targetX=player2.x;player2.targetY=player2.y;resetPuck(); }
        function resetPuck(servingPlayer=null) { /* (変更なし) */ puck.x=canvasWidth/2;puck.y=canvasHeight/2;let s=canvasWidth/100;if(servingPlayer===1)puck.vy=s;else if(servingPlayer===2)puck.vy=-s;else puck.vy=(Math.random()>0.5?1:-1)*s;puck.vx=(Math.random()>0.5?1:-1)*s*0.7; }
        
        function resetGame(isAIopponent) {
            player1.score = 0;
            player2.score = 0;
            player2.isAI = isAIopponent;
            // 名前の設定は updateScoreDisplay に移譲またはここで明示的に
            if (localPlayerRole === 'host' || gameMode === 'ai_solo' || gameMode === 'host_waiting_ai') {
                player1.name = "あなた";
                player2.name = isAIopponent ? "AI" : "友達";
            } else if (localPlayerRole === 'client') {
                player1.name = "友達"; // ホストがP1
                player2.name = "あなた"; // クライアントがP2
            }
            updateScoreDisplay();
            initGameElements();
            if (gameMode === 'p2p_playing' && localPlayerRole === 'host' && conn && conn.open) {
                 sendP2PData({ type: 'game_reset_p2p' });
            }
        }

        function updateScoreDisplay() {
            let p1DisplayName = player1.name;
            let p2DisplayName = player2.name;
            let p1DisplayScore = player1.score;
            let p2DisplayScore = player2.score;

            if (gameMode === 'p2p_playing' && localPlayerRole === 'client') {
                // クライアント視点: 自分がプレイヤー2（下側）、相手がプレイヤー1（上側）
                p1DisplayName = player2.name; // P2 (あなた)
                p2DisplayName = player1.name; // P1 (友達)
                p1DisplayScore = player2.score;
                p2DisplayScore = player1.score;
            } else if (gameMode === 'host_waiting_ai' || gameMode === 'ai_solo') {
                 p1DisplayName = player1.name; // あなた
                 p2DisplayName = player2.name; // AI
                 p1DisplayScore = player1.score;
                 p2DisplayScore = player2.score;
            } else if (gameMode === 'p2p_playing' && localPlayerRole === 'host') {
                 p1DisplayName = player1.name; // あなた (ホスト)
                 p2DisplayName = player2.name; // 友達 (クライアント)
                 p1DisplayScore = player1.score;
                 p2DisplayScore = player2.score;
            }


            scoreDisplay.textContent = `${p1DisplayName}: ${p1DisplayScore} - ${p2DisplayName}: ${p2DisplayScore}`;
        }

        function drawCircle(x,y,r,c){ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.fillStyle=c;ctx.fill();ctx.closePath();}
        function drawField(){ctx.clearRect(0,0,canvasWidth,canvasHeight);ctx.beginPath();ctx.moveTo(0,canvasHeight/2);ctx.lineTo(canvasWidth,canvasHeight/2);ctx.strokeStyle='#ccc';ctx.lineWidth=2;ctx.stroke();ctx.beginPath();ctx.arc(canvasWidth/2,canvasHeight/2,canvasWidth/8,0,Math.PI*2);ctx.stroke();ctx.fillStyle='lightgrey';const gh=PUCK_RADIUS*1.5;ctx.fillRect((canvasWidth-GOAL_WIDTH)/2,0,GOAL_WIDTH,gh);ctx.fillRect((canvasWidth-GOAL_WIDTH)/2,canvasHeight-gh,GOAL_WIDTH,gh);}
        function updatePaddlePosition(paddle){let dx=paddle.targetX-paddle.x,dy=paddle.targetY-paddle.y;paddle.x+=dx*PADDLE_SPEED_FACTOR;paddle.y+=dy*PADDLE_SPEED_FACTOR;paddle.x=Math.max(paddle.radius,Math.min(canvasWidth-paddle.radius,paddle.x));if(paddle===player1||(localPlayerRole==='client'&&paddle===player2&&gameMode==='p2p_playing')){paddle.y=Math.max(canvasHeight/2+paddle.radius,Math.min(canvasHeight-paddle.radius,paddle.y));}else{paddle.y=Math.max(paddle.radius,Math.min(canvasHeight/2-paddle.radius,paddle.y));}}
        function aiMove(){if(!player2.isAI||gameMode==='p2p_playing')return;let tX,tY;const rDY=canvasHeight*0.6,cSTY=canvasHeight*0.25;if(puck.y<cSTY&&puck.vy<=0.1&&Math.abs(puck.vx)<1){tX=canvasWidth/2;tY=puck.y-player2.radius*2;}else if(puck.vy<0&&puck.y<rDY){tX=puck.x;tY=puck.y-player2.radius*1.2;}else{tX=canvasWidth/2;tY=canvasHeight*0.15;}player2.targetX=tX;player2.targetY=Math.max(player2.radius,Math.min(canvasHeight/2-player2.radius,tY));}
        function updateGamePhysics(){puck.x+=puck.vx;puck.y+=puck.vy;puck.vx*=0.995;puck.vy*=0.995;if(puck.x+puck.radius>canvasWidth||puck.x-puck.radius<0){puck.vx*=-1;puck.x=(puck.x-puck.radius<0)?puck.radius:canvasWidth-puck.radius;}const gh=PUCK_RADIUS*1.5;if((puck.y+puck.radius>canvasHeight&&(puck.x<(canvasWidth-GOAL_WIDTH)/2||puck.x>(canvasWidth+GOAL_WIDTH)/2))||(puck.y-puck.radius<0&&(puck.x<(canvasWidth-GOAL_WIDTH)/2||puck.x>(canvasWidth+GOAL_WIDTH)/2))){puck.vy*=-1;puck.y=(puck.y-puck.radius<0)?puck.radius:canvasHeight-gh+puck.radius;if(puck.y+puck.radius>canvasHeight)puck.y=canvasHeight-puck.radius;}checkCollision(player1,puck);checkCollision(player2,puck);let s=false;let scoredPlayer = null; if(puck.y-puck.radius<gh&&puck.x>(canvasWidth-GOAL_WIDTH)/2&&puck.x<(canvasWidth+GOAL_WIDTH)/2){(localPlayerRole==='client'?player2:player1).score++;s=true;scoredPlayer=(localPlayerRole==='client'?2:1);}else if(puck.y+puck.radius>canvasHeight-gh&&puck.x>(canvasWidth-GOAL_WIDTH)/2&&puck.x<(canvasWidth+GOAL_WIDTH)/2){(localPlayerRole==='client'?player1:player2).score++;s=true;scoredPlayer=(localPlayerRole==='client'?1:2);}if(s){updateScoreDisplay();checkWin();if(gameMode!=='game_over')resetPuck(scoredPlayer === 1 ? 2 : (scoredPlayer === 2 ? 1 : null)); if(localPlayerRole==='host'&&conn&&conn.open)sendP2PData({type:'score_update',scores:{player1:player1.score,player2:player2.score}, scoredPlayer: scoredPlayer});}}
        function gameLoop(){if(gameMode==='menu'){drawField();animationFrameId=requestAnimationFrame(gameLoop);return;}updatePaddlePosition(player1);if(player2.isAI&&gameMode!=='p2p_playing'){aiMove();}updatePaddlePosition(player2);if(gameMode==='ai_solo'||gameMode==='host_waiting_ai'||(gameMode==='p2p_playing'&&localPlayerRole==='host')){updateGamePhysics();}drawField();drawCircle(player1.x,player1.y,player1.radius,'blue');drawCircle(player2.x,player2.y,player2.radius,(player2.isAI&&gameMode!=='p2p_playing')?'#E63946':(conn&&conn.open?'#2A9D8F':'#E63946'));drawCircle(puck.x,puck.y,puck.radius,'black');animationFrameId=requestAnimationFrame(gameLoop);}
        function checkCollision(paddle,puck){let dx=puck.x-paddle.x,dy=puck.y-paddle.y,d=Math.sqrt(dx*dx+dy*dy);if(d<paddle.radius+puck.radius){let a=Math.atan2(dy,dx),s=canvasWidth/65;puck.vx=Math.cos(a)*s;puck.vy=Math.sin(a)*s;let o=paddle.radius+puck.radius-d+1;puck.x+=Math.cos(a)*o;puck.y+=Math.sin(a)*o;const ms=canvasWidth/28,cs=Math.sqrt(puck.vx*puck.vx+puck.vy*puck.vy);if(cs>ms){puck.vx=(puck.vx/cs)*ms;puck.vy=(puck.vy/cs)*ms;}}}
        
        function checkWin() {
            let localPlayerWon = false;
            let localPlayerLost = false;
            let winnerName = "";

            if (gameMode === 'p2p_playing') {
                if (localPlayerRole === 'host') {
                    if (player1.score >= WINNING_SCORE) localPlayerWon = true;
                    else if (player2.score >= WINNING_SCORE) localPlayerLost = true;
                } else if (localPlayerRole === 'client') {
                    if (player2.score >= WINNING_SCORE) localPlayerWon = true; // Client is P2
                    else if (player1.score >= WINNING_SCORE) localPlayerLost = true;
                }
            } else { // AI戦 (host_waiting_ai or ai_solo)
                if (player1.score >= WINNING_SCORE) localPlayerWon = true;
                else if (player2.score >= WINNING_SCORE) localPlayerLost = true;
            }

            if (localPlayerWon) winnerName = "あなたの勝ち";
            else if (localPlayerLost) winnerName = "あなたの負け";


            if (localPlayerWon || localPlayerLost) {
                const oldGameMode = gameMode;
                gameStatusDisplay.textContent = winnerName + "！";
                gameMode = 'game_over';
                
                setTimeout(() => {
                    gameMode = oldGameMode; // 元のモードに戻るか、メニューに遷移するかは要件次第
                    if (gameMode === 'host_waiting_ai') gameStatusDisplay.textContent = '友達の参加待ち... AIと対戦中';
                    else if (gameMode === 'p2p_playing') gameStatusDisplay.textContent = 'P2P対戦中';
                    else if (gameMode === 'ai_solo') gameStatusDisplay.textContent = 'AIと対戦中';
                    
                    if (gameMode !== 'menu' && gameMode !== 'game_over') {
                         resetGame(player2.isAI); // isAIは直前の状態を維持
                    } else if (gameMode === 'game_over'){ // ゲームオーバー後さらに時間が経ったらメニューへ
                        cleanupAndShowInitialScreen();
                    }
                }, 3000);
            }
        }

        function handleMove(clientX, clientY) {
            if (gameMode === 'menu' || gameMode === 'game_over') return;
            const rect = canvas.getBoundingClientRect();
            let x = (clientX - rect.left) * (canvas.width / rect.width);
            let y = (clientY - rect.top) * (canvas.height / rect.height);

            let controlledPaddle = player1; // デフォルトはplayer1
            if (gameMode === 'p2p_playing' && localPlayerRole === 'client') {
                controlledPaddle = player2; // クライアントならplayer2を操作 (表示上は下側)
            }
            
            controlledPaddle.targetX = x;
            controlledPaddle.targetY = y;

            if (conn && conn.open) {
                let p2pX = controlledPaddle.x;
                let p2pY = controlledPaddle.y;
                // クライアントが操作情報を送る場合、ホストの座標系(P1が下)に合わせる
                // ホストが操作情報を送る場合も、P1の座標(そのまま)を送る
                if (localPlayerRole === 'client') {
                    p2pX = canvasWidth - controlledPaddle.x; // クライアントのP2パドルはホストから見ると反転
                    p2pY = canvasHeight - controlledPaddle.y;
                }
                sendP2PData({type: 'paddle_move', x: p2pX, y: p2pY });
            }
        }
        
        // タッチイベントのリスナー (ドラッグ操作)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (e.touches.length > 0) {
                isTouching = true;
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isTouching && e.touches.length > 0) {
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isTouching = false;
        }, { passive: false });
        canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            isTouching = false;
        }, { passive: false });

        // マウスイベント (PCでのテスト用)
        canvas.addEventListener('mousedown', (e) => { isTouching = true; handleMove(e.clientX, e.clientY);});
        canvas.addEventListener('mousemove', (e) => { if (isTouching && e.buttons === 1) handleMove(e.clientX, e.clientY);});
        canvas.addEventListener('mouseup', () => { isTouching = false; });
        canvas.addEventListener('mouseleave', () => { isTouching = false; }); // キャンバス外に出たらドラッグ解除
        

        function sendP2PData(data){if(conn&&conn.open){conn.send(JSON.stringify(data));}}
        function handleP2PData(jsonData){try{const d=JSON.parse(jsonData);if(d.type==='paddle_move'){if(localPlayerRole==='host'){player2.x=canvasWidth-d.x;player2.y=canvasHeight-d.y;}else if(localPlayerRole==='client'){player1.x=canvasWidth-d.x;player1.y=canvasHeight-d.y;}}else if(d.type==='puck_state'){if(localPlayerRole==='client'){puck.x=canvasWidth-d.puck.x;puck.y=canvasHeight-d.puck.y;puck.vx=-d.puck.vx;puck.vy=-d.puck.vy;}}else if(d.type==='score_update'){if(localPlayerRole==='client'){player1.score=d.scores.player1;player2.score=d.scores.player2;updateScoreDisplay();if(d.scoredPlayer) resetPuck(d.scoredPlayer === 1 ? 2 : 1);}}else if(d.type==='game_reset_p2p'){if(localPlayerRole==='client'){player1.score=0;player2.score=0;player2.isAI=false;player2.name="あなた";player1.name="友達";initGameElements();updateScoreDisplay();gameStatusDisplay.textContent="ホストがリセット";}}else if(d.type==='game_start_ack'&&localPlayerRole==='client'){gameMode='p2p_playing';player2.isAI=false;player1.name="友達";player2.name="あなた";gameStatusDisplay.textContent='P2P対戦開始！';initialControls.classList.add('hidden');p2pClientInfo.classList.add('hidden');resetGame(false);updateScoreDisplay();}}catch(e){console.error("P2Pデータエラー:",e);}}

        hostGameButton.addEventListener('click', () => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            cleanupPeerResources(); 
            localPlayerRole = 'host';
            gameMode = 'host_waiting_ai'; // AIと対戦しながら待機
            player1.name = "あなた"; player2.isAI = true; player2.name = "AI";
            
            initialControls.classList.add('hidden');
            p2pHostInfo.classList.remove('hidden');
            p2pClientInfo.classList.add('hidden');
            gameStatusDisplay.textContent = 'Peer ID取得中...';

            peer = new Peer(); 
            peer.on('open', (id) => {
                myPeerId = id;
                gameStatusDisplay.textContent = '友達の参加待ち... AIと対戦中';
                qrCodeContainer.innerHTML = '';
                const joinUrl = `${window.location.origin}${window.location.pathname}?join=${myPeerId}`;
                new QRCode(qrCodeContainer, { text: joinUrl, width: 150, height: 150 });
                roomInfoDisplay.textContent = `部屋ID: ${myPeerId.substring(0,8)}...\nURLあり`; // URLはQRにあるので省略
                
                resizeCanvas(); // gameModeが設定された後に呼ぶ
                resetGame(true); 
                if(!animationFrameId) gameLoop(); // 最初のループ開始
            });
            peer.on('connection', (newConnection) => {
                if (conn && conn.open) { newConnection.send(JSON.stringify({type:'error',message:'Host busy'}));setTimeout(()=>newConnection.close(),500);return; }
                conn = newConnection;
                gameStatusDisplay.textContent = `友達 (${conn.peer.substring(0,6)}...) が参加！`;
                
                conn.on('open', () => {
                    gameMode = 'p2p_playing'; player2.isAI = false; player2.name = "友達";
                    p2pHostInfo.classList.add('hidden'); 
                    resetGame(false); 
                    sendP2PData({ type: 'game_start_ack' }); 
                    updateScoreDisplay(); // P2P用にスコア表示更新
                });
                conn.on('data', handleP2PData);
                conn.on('close', () => { gameStatusDisplay.textContent='友達切断。AI待機に戻ります。';conn=null;if(gameMode==='p2p_playing')startAIWaitingModeForHost();});
                conn.on('error', (err) => { console.error("Connエラー(H):",err);gameStatusDisplay.textContent=`接続エラー:${err.type}。AI待機に戻ります。`;if(conn)conn.close();conn=null;if(gameMode==='p2p_playing')startAIWaitingModeForHost();});
            });
            peer.on('error', handlePeerError);
            peer.on('disconnected', () => { gameStatusDisplay.textContent="P2P鯖から切断";cleanupAndShowInitialScreen();});
        });
        
        function startAIWaitingModeForHost(){
            gameMode = 'host_waiting_ai'; player2.isAI = true; player2.name = "AI";
            gameStatusDisplay.textContent = '友達の参加待ち... AIと対戦中';
            p2pHostInfo.classList.remove('hidden'); resetGame(true); updateScoreDisplay();
        }

        cancelHostButton.addEventListener('click', cleanupAndShowInitialScreen);
        function cleanupAndShowInitialScreen(){if(animationFrameId)cancelAnimationFrame(animationFrameId);animationFrameId=null;cleanupPeerResources();gameMode='menu';localPlayerRole=null;player1.name="あなた";player2.name="AI";player1.score=0;player2.score=0;updateScoreDisplay();initialControls.classList.remove('hidden');p2pHostInfo.classList.add('hidden');p2pClientInfo.classList.add('hidden');gameStatusDisplay.textContent='モードを選択';drawField();if(!animationFrameId)gameLoop();}
        function handlePeerError(err){console.error('PeerJSエラー:',err);gameStatusDisplay.textContent=`P2Pエラー:${err.type}。リロード推奨`;cleanupPeerResources();initialControls.classList.remove('hidden');p2pHostInfo.classList.add('hidden');p2pClientInfo.classList.add('hidden');if(animationFrameId)cancelAnimationFrame(animationFrameId);animationFrameId=null;gameMode='menu';}
        
        window.addEventListener('resize', resizeCanvas);
        function initializeApp(){
            const urlParams=new URLSearchParams(window.location.search);
            hostPeerIdToConnect=urlParams.get('join');
            if(hostPeerIdToConnect){
                if(animationFrameId)cancelAnimationFrame(animationFrameId);animationFrameId=null;
                cleanupPeerResources();localPlayerRole='client';gameMode='p2p_client_joining';
                player1.name="友達";player2.name="あなた";player2.isAI=false; // 自分がP2
                initialControls.classList.add('hidden');p2pHostInfo.classList.add('hidden');p2pClientInfo.classList.remove('hidden');
                joinStatusDisplay.textContent=`ホスト ${hostPeerIdToConnect.substring(0,6)}... に接続中...`;
                peer=new Peer();
                peer.on('open',(id)=>{myPeerId=id;conn=peer.connect(hostPeerIdToConnect,{reliable:true});
                    conn.on('open',()=>{gameMode='p2p_playing';gameStatusDisplay.textContent='P2P対戦開始！';resetGame(false);updateScoreDisplay();if(!animationFrameId)gameLoop();});
                    conn.on('data',handleP2PData);
                    conn.on('close',()=>{gameStatusDisplay.textContent='ホスト切断';cleanupAndShowInitialScreen();});
                    conn.on('error',(err)=>{console.error("Connエラー(C):",err);joinStatusDisplay.textContent=`接続エラー:${err.type}`;cleanupAndShowInitialScreen();});
                });
                peer.on('error',handlePeerError);
                peer.on('disconnected',()=>{gameStatusDisplay.textContent="P2P鯖から切断";cleanupAndShowInitialScreen();});
            }else{
                gameMode='menu';initialControls.classList.remove('hidden');p2pHostInfo.classList.add('hidden');p2pClientInfo.classList.add('hidden');gameStatusDisplay.textContent='モードを選択';
            }
            resizeCanvas();
            if(!animationFrameId)gameLoop(); 
        }
        initializeApp();
    </script>
</body>
</html>
